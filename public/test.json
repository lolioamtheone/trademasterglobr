import { useEffect, useRef, useState } from "react";
import Globe from "globe.gl";
import * as THREE from "three";

// â”€â”€ Centroids [lng, lat] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CENTROIDS = {
  "China":                    [ 104.195,  35.861],
  "United States of America": [ -95.712,  37.090],
  "Brazil":                   [ -51.925, -14.235],
  "Germany":                  [  10.451,  51.165],
  "India":                    [  78.962,  20.593],
  "Russia":                   [ 105.318,  61.524],
  "Japan":                    [ 138.252,  36.204],
  "France":                   [   2.213,  46.227],
  "United Kingdom":           [  -3.436,  55.378],
  "Canada":                   [ -96.816,  56.130],
  "Australia":                [ 133.775, -25.274],
  "South Korea":              [ 127.766,  35.907],
  "Mexico":                   [-102.552,  23.634],
  "Indonesia":                [ 113.921,  -0.789],
  "Saudi Arabia":             [  45.079,  23.885],
  "Argentina":                [ -63.616, -38.416],
  "South Africa":             [  22.937, -30.559],
  "Nigeria":                  [   8.675,   9.082],
  "Egypt":                    [  30.802,  26.820],
  "Turkey":                   [  35.243,  38.963],
};

function centroid(name) { return CENTROIDS[name] ?? [0, 0]; }

// â”€â”€ Math â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const D2R = Math.PI / 180;
const R2D = 180 / Math.PI;
const GR  = 100; // globe.gl internal radius

function toXYZ(lat, lng, alt = 0) {
  const r = GR * (1 + alt);
  const p = lat * D2R, l = lng * D2R;
  // globe.gl uses: x=cos(lat)cos(lng), y=sin(lat), z=-cos(lat)sin(lng)
  return new THREE.Vector3(
    r * Math.cos(p) * Math.cos(l),
    r * Math.sin(p),
   -r * Math.cos(p) * Math.sin(l)
  );
}

// Great-circle slerp, returns [lng, lat]
function slerp(fromLL, toLL, t) {
  const [lo1, la1] = fromLL, [lo2, la2] = toLL;
  const p1 = la1*D2R, l1 = lo1*D2R;
  const p2 = la2*D2R, l2 = lo2*D2R;
  const ax = Math.cos(p1)*Math.cos(l1), ay = Math.cos(p1)*Math.sin(l1), az = Math.sin(p1);
  const bx = Math.cos(p2)*Math.cos(l2), by = Math.cos(p2)*Math.sin(l2), bz = Math.sin(p2);
  const dot = Math.min(1, ax*bx + ay*by + az*bz);
  const O   = Math.acos(dot);
  if (Math.abs(O) < 1e-7) return fromLL;
  const s = Math.sin(O);
  const a = Math.sin((1-t)*O)/s, b = Math.sin(t*O)/s;
  const cx = a*ax+b*bx, cy = a*ay+b*by, cz = a*az+b*bz;
  return [Math.atan2(cy, cx)*R2D, Math.asin(cz)*R2D];
}

function arcAlt(t, peak=0.35) { return Math.sin(t*Math.PI)*peak; }
// Smooth cubic ease-in-out
function eio(t) { return t*t*(3-2*t); }
// Extra-smooth quintic ease
function eio5(t) { return t*t*t*(t*(t*6-15)+10); }

// â”€â”€ Cone arrowhead (3D, visible from any angle) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function arrowGeo() {
  // Cone pointing in +Y, we'll rotate it to match direction
  return new THREE.ConeGeometry(1.8, 5, 12);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export default function GlobeComponent() {
  const mountRef = useRef(null);
  const globeRef = useRef(null);
  const geoRef   = useRef(null);
  const seqRef   = useRef({ stop: false, raf: null });

  const [tradeData,    setTradeData]    = useState([]);
  const [currentIndex, setCurrentIndex] = useState(-1);
  const [phase,        setPhase]        = useState("loading");
  const [status,       setStatus]       = useState("Loadingâ€¦");

  // â”€â”€ Load JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    fetch("/test.json")
      .then(r => r.json())
      .catch(() => [
        { country:"China",                    role:"exporter", material:"Silicon Wafers",        hs_code:"3818.00" },
        { country:"United States of America", role:"importer", material:"Lithium-ion Batteries", hs_code:"8507.60" },
        { country:"Brazil",                   role:"importer", material:"Refined Petroleum",      hs_code:"2710.12" },
      ])
      .then(raw => {
        const sorted = [...raw].sort((a,b) =>
          a.role==="exporter" && b.role!=="exporter" ? -1 :
          a.role!=="exporter" && b.role==="exporter" ?  1 : 0
        );
        setTradeData(sorted);
        setPhase("ready");
      });
  }, []);

  // â”€â”€ Init Globe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (!mountRef.current) return;

    const world = Globe()(mountRef.current)
      .globeImageUrl("https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg")
      .bumpImageUrl("https://unpkg.com/three-globe/example/img/earth-topology.png")
      .backgroundColor("rgba(0,0,0,0)")
      .atmosphereColor("#1060ff")
      .atmosphereAltitude(0.20)
      .polygonsData([])
      .polygonAltitude(0.008)
      .polygonCapColor(d  => d.__cap  || "rgba(255,255,255,0.03)")
      .polygonSideColor(() => "rgba(80,150,255,0.04)")
      .polygonStrokeColor(() => "#1a4488")
      .labelsData([])
      .labelLat(d => d.lat).labelLng(d => d.lng).labelText(d => d.text)
      .labelSize(1.2).labelDotRadius(0.45).labelColor(d => d.color)
      .labelResolution(3).labelAltitude(0.015);

    world.renderer().setClearColor(0x000005, 1);

    // Lighting
    const sc = world.scene();
    sc.add(new THREE.AmbientLight(0x223355, 3.2));
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(5,3,5); sc.add(sun);

    // Halo glow
    const gc = document.createElement("canvas");
    gc.width = gc.height = 512;
    const gx = gc.getContext("2d");
    const gr = gx.createRadialGradient(256,256,80,256,256,256);
    gr.addColorStop(0,   "rgba(20,100,255,0.22)");
    gr.addColorStop(0.5, "rgba(10,55,200,0.08)");
    gr.addColorStop(1,   "rgba(0,0,0,0)");
    gx.fillStyle = gr; gx.fillRect(0,0,512,512);
    const halo = new THREE.Sprite(new THREE.SpriteMaterial({
      map: new THREE.CanvasTexture(gc),
      blending: THREE.AdditiveBlending, depthWrite: false, transparent: true,
    }));
    halo.scale.set(400, 400, 1); sc.add(halo);

    // â”€â”€ Disable ALL automatic camera controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // We will manually position camera every frame
    const ctrl = world.controls();
    ctrl.enabled       = false; // completely disable OrbitControls
    ctrl.autoRotate    = false;
    ctrl.enableDamping = false;

    globeRef.current = world;

    // Initial camera position: look at globe from the front
    const cam = world.camera();
    cam.position.set(0, 50, 280);
    cam.lookAt(0, 0, 0);

    // GeoJSON borders
    fetch("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson")
      .then(r => r.json())
      .then(geo => {
        geoRef.current = geo.features;
        world.polygonsData(geo.features);
      });

    return () => { if (mountRef.current) mountRef.current.innerHTML = ""; };
  }, []);

  // â”€â”€ Sequence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (phase !== "ready" || tradeData.length < 2 || !globeRef.current) return;

    const world = globeRef.current;
    const seq   = { stop: false, raf: null };
    seqRef.current = seq;

    const ROLE = {
      exporter: { cap:"rgba(0,255,120,0.30)", label:"#00ff78" },
      importer: { cap:"rgba(0,160,255,0.30)", label:"#00b0ff" },
    };
    const ARC_MS   = 2600;
    const PAUSE_MS = 4000;
    const TUBE_R   = 0.9;   // tube radius in globe units â€” visible thickness
    const TUBE_SEG = 6;     // radial segments on tube

    // â”€â”€ Camera state for smooth damping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Instead of snapping camera each frame, we lerp toward a target position
    const camTarget = new THREE.Vector3();
    let   camSmooth = false;
    const CAM_DAMP  = 0.10; // 0=no smoothing, 1=instant; 0.10 = nicely damped

    function positionCamera(lat, lng, dist, instant=false) {
      const cam    = world.camera();
      const outDir = toXYZ(lat, lng, 0).normalize();
      const target = outDir.multiplyScalar(dist);
      if (instant) {
        cam.position.copy(target);
        cam.lookAt(0, 0, 0);
        cam.updateMatrixWorld(true);
        camTarget.copy(target);
      } else {
        camTarget.copy(target);
      }
    }

    // Call this every rAF to smoothly move camera toward camTarget
    function tickCamera() {
      const cam = world.camera();
      cam.position.lerp(camTarget, CAM_DAMP);
      cam.lookAt(0, 0, 0);
      cam.updateMatrixWorld(true);
    }

    // â”€â”€ Smooth camera lerp over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function lerpCamera(fromLL, toLL, fromDist, toDist, ms) {
      return new Promise(resolve => {
        const start = performance.now();
        function tick(now) {
          if (seq.stop) return resolve();
          const raw = Math.min((now - start) / ms, 1);
          const t   = eio5(raw);
          const [lng, lat] = slerp(fromLL, toLL, t);
          const dist = fromDist + (toDist - fromDist) * t;
          positionCamera(lat, lng, dist, true); // instant=true during explicit lerp
          if (raw < 1) seq.raf = requestAnimationFrame(tick);
          else resolve();
        }
        seq.raf = requestAnimationFrame(tick);
      });
    }

    // â”€â”€ Highlight country polygons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function highlight(name, role) {
      if (!geoRef.current) return;
      geoRef.current.forEach(f => {
        const n = f.properties.ADMIN || f.properties.NAME || "";
        f.__cap = n === name ? ROLE[role]?.cap : "rgba(255,255,255,0.03)";
      });
      world.polygonsData([...geoRef.current]);
    }

    function addLabel(lat, lng, text, color) {
      world.labelsData([...world.labelsData(), { lat:lat+4, lng, text, color }]);
    }

    // â”€â”€ Tube-based thick line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // We rebuild a TubeGeometry each frame up to the current tip index.
    // TubeGeometry renders a real 3D tube â€” thickness works on all WebGL drivers.
    let liveTubeMesh = null;
    const tubeMat = new THREE.MeshBasicMaterial({
      color: 0xffee00,
      transparent: true,
      opacity: 1,
    });
    // Glow halo around tube: slightly larger, additive blend
    const tubeGlowMat = new THREE.MeshBasicMaterial({
      color: 0xff9900,
      transparent: true,
      opacity: 0.25,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    let liveGlowMesh = null;

    function updateTube(pts) {
      // Remove old meshes
      if (liveTubeMesh) { world.scene().remove(liveTubeMesh); liveTubeMesh.geometry.dispose(); }
      if (liveGlowMesh) { world.scene().remove(liveGlowMesh); liveGlowMesh.geometry.dispose(); }
      if (pts.length < 2) return;

      const curve = new THREE.CatmullRomCurve3(pts);
      const segs  = Math.max(pts.length * 3, 20);
      const geo   = new THREE.TubeGeometry(curve, segs, TUBE_R, TUBE_SEG, false);
      const glowG = new THREE.TubeGeometry(curve, segs, TUBE_R * 2.8, TUBE_SEG, false);

      liveTubeMesh = new THREE.Mesh(geo, tubeMat);
      liveGlowMesh = new THREE.Mesh(glowG, tubeGlowMat);
      liveTubeMesh.frustumCulled = false;
      liveGlowMesh.frustumCulled = false;
      world.scene().add(liveGlowMesh);
      world.scene().add(liveTubeMesh);
    }

    function clearTube() {
      if (liveTubeMesh) { world.scene().remove(liveTubeMesh); liveTubeMesh.geometry.dispose(); liveTubeMesh = null; }
      if (liveGlowMesh) { world.scene().remove(liveGlowMesh); liveGlowMesh.geometry.dispose(); liveGlowMesh = null; }
    }

    // Add a permanent dim tube after animation finishes
    function bakePermanent(fromLL, toLL) {
      const N = 80, pts = [];
      for (let i = 0; i <= N; i++) {
        const t = i/N;
        const [lng,lat] = slerp(fromLL, toLL, t);
        pts.push(toXYZ(lat, lng, arcAlt(t, 0.35)));
      }
      const curve = new THREE.CatmullRomCurve3(pts);
      const geo   = new THREE.TubeGeometry(curve, pts.length*2, TUBE_R*0.5, TUBE_SEG, false);
      const mat   = new THREE.MeshBasicMaterial({ color:0xff7700, transparent:true, opacity:0.18 });
      const mesh  = new THREE.Mesh(geo, mat);
      mesh.frustumCulled = false;
      world.scene().add(mesh);
    }

    const arrowMat  = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
    const arrowMesh = new THREE.Mesh(arrowGeo(), arrowMat);
    arrowMesh.frustumCulled = false;
    arrowMesh.visible = false;
    world.scene().add(arrowMesh);

    // â”€â”€ Animate arc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function animateArc(fromEntry, toEntry) {
      return new Promise(resolve => {
        if (seq.stop) return resolve();

        const fromLL = centroid(fromEntry.country);
        const toLL   = centroid(toEntry.country);
        const N      = 160; // high density for smooth tube

        // Pre-bake all arc points
        const arcPts = Array.from({ length: N+1 }, (_, i) => {
          const t          = i / N;
          const [lng, lat] = slerp(fromLL, toLL, t);
          const alt        = arcAlt(t, 0.35);
          return { lat, lng, alt, xyz: toXYZ(lat, lng, alt) };
        });

        arrowMesh.visible = true;
        let t0 = null;
        // How many tube points we rendered last frame (avoid rebuilding if same)
        let lastIdx = -1;

        function frame(now) {
          if (seq.stop) return resolve();
          if (!t0) t0 = now;

          const raw = Math.min((now - t0) / ARC_MS, 1);
          const t   = eio5(raw);
          const idx = Math.min(Math.floor(t * N), N);

          // Only rebuild tube when tip has advanced
          if (idx !== lastIdx && idx >= 1) {
            updateTube(arcPts.slice(0, idx + 1).map(p => p.xyz));
            lastIdx = idx;
          }

          // â”€â”€ Arrowhead at tip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const tip  = arcPts[idx];
          const prev = arcPts[Math.max(idx - 2, 0)]; // use idx-2 for smoother direction
          const dir  = new THREE.Vector3().subVectors(tip.xyz, prev.xyz).normalize();
          const up   = tip.xyz.clone().normalize();
          // Orient cone: ConeGeometry points in +Y by default
          const quat = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 1, 0), dir
          );
          arrowMesh.position.copy(tip.xyz);
          arrowMesh.quaternion.copy(quat);
          arrowMesh.scale.setScalar(GR * 0.028);

          // â”€â”€ Camera: smooth-damped, locked to tip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const camDist = GR * (1.55 + tip.alt * 2.6);
          positionCamera(tip.lat, tip.lng, camDist); // sets camTarget
          tickCamera(); // lerp toward target this frame

          if (raw < 1) {
            seq.raf = requestAnimationFrame(frame);
          } else {
            resolve();
          }
        }

        seq.raf = requestAnimationFrame(frame);
      });
    }

    // â”€â”€ promise-based sleep â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function wait(ms) {
      return new Promise(res => {
        const id = setTimeout(res, ms);
        seq._tid = id;
      });
    }

    // â”€â”€ Main sequence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function run() {
      const first      = tradeData[0];
      const firstLL    = centroid(first.country);
      const [fLng,fLat] = firstLL;

      setCurrentIndex(0);
      setStatus(`Flying to ${first.country}â€¦`);
      highlight(first.country, first.role);

      // Fly camera to first country
      const startLL   = [0, 20];
      const startDist = GR * 2.85;
      const endDist   = GR * 1.80;
      await lerpCamera(startLL, firstLL, startDist, endDist, 2200);
      if (seq.stop) return;

      addLabel(fLat, fLng,
        `${first.role==="exporter"?"ðŸ“¤":"ðŸ“¥"} ${first.country}`,
        ROLE[first.role]?.label || "#fff"
      );

      await wait(900);
      if (seq.stop) return;

      // Arc loop
      for (let i = 0; i < tradeData.length - 1; i++) {
        if (seq.stop) return;

        const fromE  = tradeData[i];
        const toE    = tradeData[i+1];
        const toLL   = centroid(toE.country);
        const [toLng, toLat] = toLL;

        setStatus(`${fromE.country}  â”€â”€â–¶  ${toE.country}`);
        setCurrentIndex(i);

        // Draw arc with camera tracking tip
        await animateArc(fromE, toE);
        if (seq.stop) return;

        // Bake dim permanent trail
        bakePermanent(centroid(fromE.country), toLL);

        // Hide live arc
        clearTube();
        arrowMesh.visible = false;

        // Highlight destination
        highlight(toE.country, toE.role);
        setCurrentIndex(i+1);

        addLabel(toLat, toLng,
          `${toE.role==="exporter"?"ðŸ“¤":"ðŸ“¥"} ${toE.country}`,
          ROLE[toE.role]?.label || "#fff"
        );

        // Ease camera back slightly to show country (instant lerp, no arc tracking)
        const toLL2     = toLL;
        const [, toLat2] = toLL2;
        const curDist   = GR * (1.55 + arcAlt(1, 0.35) * 2.6);
        await lerpCamera(toLL, toLL, curDist, GR * 1.80, 700);
        if (seq.stop) return;

        setStatus(`${toE.country} â€” ${toE.material}`);
        await wait(PAUSE_MS);
        if (seq.stop) return;
      }

      setPhase("done");
      setStatus("All trade routes mapped.");
    }

    run();

    return () => {
      seq.stop = true;
      if (seq.raf) cancelAnimationFrame(seq.raf);
      if (seq._tid) clearTimeout(seq._tid);
      clearTube();
    };
  }, [phase, tradeData]);

  // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const cur = tradeData[currentIndex] ?? null;
  const rs  = cur?.role === "exporter"
    ? { text:"#00ff78", border:"rgba(0,255,120,0.4)", bg:"rgba(0,255,120,0.07)" }
    : { text:"#00b0ff", border:"rgba(0,160,255,0.4)", bg:"rgba(0,160,255,0.07)" };

  return (
    <div style={{ width:"100vw", height:"100vh", background:"#000005", position:"relative", overflow:"hidden" }}>
      <div ref={mountRef} style={{ width:"100%", height:"100%" }} />

      {/* Title */}
      <div style={{
        position:"absolute", top:22, left:"50%", transform:"translateX(-50%)",
        fontFamily:"'Courier New',monospace", color:"#4a9fff", fontSize:13,
        letterSpacing:"0.22em", textTransform:"uppercase",
        textShadow:"0 0 14px #4a9fff88", userSelect:"none", whiteSpace:"nowrap",
      }}>
        â¬¡ &nbsp; Global Trade Flow Visualizer &nbsp; â¬¡
      </div>

      {/* Progress bar */}
      {tradeData.length > 1 && (
        <div style={{
          position:"absolute", top:52, left:"50%", transform:"translateX(-50%)",
          width:280, height:2, background:"rgba(255,255,255,0.07)", borderRadius:2,
        }}>
          <div style={{
            height:"100%",
            width:`${((currentIndex+1)/tradeData.length)*100}%`,
            background:"linear-gradient(90deg,#00ff78,#00b0ff)",
            borderRadius:2, transition:"width 0.5s ease",
            boxShadow:"0 0 10px #00b0ff88",
          }}/>
        </div>
      )}

      {/* Status */}
      <div style={{
        position:"absolute", top:63, left:"50%", transform:"translateX(-50%)",
        fontFamily:"'Courier New',monospace", fontSize:11,
        color:"rgba(120,180,255,0.5)", letterSpacing:"0.12em", whiteSpace:"nowrap",
      }}>
        {status}
      </div>

      {/* Country card */}
      {cur && (
        <div key={currentIndex} style={{
          position:"absolute", bottom:38, left:38,
          background:rs.bg, border:`1px solid ${rs.border}`,
          borderRadius:12, padding:"16px 22px",
          fontFamily:"'Courier New',monospace", color:"#fff",
          backdropFilter:"blur(10px)",
          boxShadow:`0 0 28px ${rs.border}`, minWidth:230,
          animation:"fadeUp 0.4s ease",
        }}>
          <div style={{ color:rs.text, fontSize:17, fontWeight:"bold", marginBottom:3 }}>
            {cur.country}
          </div>
          <div style={{ color:"#777", fontSize:10, letterSpacing:"0.18em", marginBottom:8 }}>
            {cur.role.toUpperCase()} &nbsp;Â·&nbsp; HS {cur.hs_code}
          </div>
          <div style={{ color:"#ddd", fontSize:13 }}>{cur.material}</div>
        </div>
      )}

      {/* Step counter */}
      <div style={{
        position:"absolute", bottom:38, right:38,
        fontFamily:"'Courier New',monospace",
        color:"rgba(100,170,255,0.45)", fontSize:12,
        letterSpacing:"0.1em", textAlign:"right",
      }}>
        {phase==="done" ? "âœ“  ALL ROUTES MAPPED"
          : tradeData.length > 0
            ? `STOP ${Math.min(currentIndex+1,tradeData.length)} / ${tradeData.length}`
            : ""}
      </div>

      {/* Legend */}
      <div style={{
        position:"absolute", top:86, right:28,
        fontFamily:"'Courier New',monospace", fontSize:11,
        color:"#555", lineHeight:"22px",
      }}>
        <div><span style={{color:"#00ff78"}}>â–ˆ</span> Exporter</div>
        <div><span style={{color:"#00b0ff"}}>â–ˆ</span> Importer</div>
        <div><span style={{color:"#ffee00"}}>â€”â€”â–¶</span> Route</div>
      </div>

      <style>{`
        @keyframes fadeUp {
          from { opacity:0; transform:translateY(12px); }
          to   { opacity:1; transform:translateY(0); }
        }
      `}</style>
    </div>
  );
}